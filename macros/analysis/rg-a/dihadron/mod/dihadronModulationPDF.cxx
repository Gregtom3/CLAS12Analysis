/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "dihadronModulationPDF.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(dihadronModulationPDF); 

 dihadronModulationPDF::dihadronModulationPDF(const char *name, const char *title, 
                        RooAbsReal& _Phih,
                        RooAbsReal& _PhiR,
                        RooAbsReal& _helicity,
                        RooAbsReal& _a0,
                        RooAbsReal& _a1,
                        RooAbsReal& _a2,
                        RooAbsReal& _a3,
                        RooAbsReal& _a4,
                        RooAbsReal& _a5,
                        RooAbsReal& _a6) :
   HS::FIT::RooHSEventsPDF(name,title),
   Phih("Phih","Phih",this,_Phih),
   PhiR("PhiR","PhiR",this,_PhiR),
   helicity("helicity","helicity",this,_helicity),
   a0("a0","a0",this,_a0),
   a1("a1","a1",this,_a1),
   a2("a2","a2",this,_a2),
   a3("a3","a3",this,_a3),
   a4("a4","a4",this,_a4),
   a5("a5","a5",this,_a5),
   a6("a6","a6",this,_a6)
 { 
   MakeSets();
   Phih.SetName(_Phih.GetName());
   PhiR.SetName(_PhiR.GetName());
   helicity.SetName(_helicity.GetName());
   a0.SetName(_a0.GetName());
   a1.SetName(_a1.GetName());
   a2.SetName(_a2.GetName());
   a3.SetName(_a3.GetName());
   a4.SetName(_a4.GetName());
   a5.SetName(_a5.GetName());
   a6.SetName(_a6.GetName());
 } 


 dihadronModulationPDF::dihadronModulationPDF(const dihadronModulationPDF& other, const char* name) :  
   HS::FIT::RooHSEventsPDF(other,name),
   Phih("Phih",this,other.Phih),
   PhiR("PhiR",this,other.PhiR),
   helicity("helicity",this,other.helicity),
   a0("a0",this,other.a0),
   a1("a1",this,other.a1),
   a2("a2",this,other.a2),
   a3("a3",this,other.a3),
   a4("a4",this,other.a4),
   a5("a5",this,other.a5),
   a6("a6",this,other.a6)
 { 
   MakeSets();
   Phih.SetName(other.Phih.GetName());
   PhiR.SetName(other.PhiR.GetName());
   helicity.SetName(other.helicity.GetName());
   a0.SetName(other.a0.GetName());
   a1.SetName(other.a1.GetName());
   a2.SetName(other.a2.GetName());
   a3.SetName(other.a3.GetName());
   a4.SetName(other.a4.GetName());
   a5.SetName(other.a5.GetName());
   a6.SetName(other.a6.GetName());
   if(fEvTree) SetEvTree(fEvTree,fCut);//Needs fProxSet filled first
 } 
void dihadronModulationPDF::MakeSets(){
   fProxSet.push_back(&Phih);
   fProxSet.push_back(&PhiR);
   fProxSet.push_back(&helicity);
   fParSet.push_back(&a0);
   fParSet.push_back(&a1);
   fParSet.push_back(&a2);
   fParSet.push_back(&a3);
   fParSet.push_back(&a4);
   fParSet.push_back(&a5);
   fParSet.push_back(&a6);
   InitSets();
}



 Double_t dihadronModulationPDF::evaluateData() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   return 1.0 + helicity*(a0*TMath::Sin(2*Phih - 2*PhiR)+
                                 a1*TMath::Sin(Phih-PhiR)+
                                 a2*TMath::Sin(-Phih+2*PhiR)+
                                 a3*TMath::Sin(PhiR)+
                                 a4*TMath::Sin(Phih)+
                                 a5*TMath::Sin(2*Phih-PhiR)+
                                 a6*TMath::Sin(3*Phih-2*PhiR));
 } 

Double_t dihadronModulationPDF::evaluateMC(const vector<Float_t> *vars,const  vector<Int_t> *cats) const {
// ENTER IDENTICAL EXPRESSION TO evaluate() IN TERMS OF MC VARIABLE ARGUMENTS HERE
  Double_t mcPhih=(*vars)[fTreeEntry*fNvars+0];
  Double_t mcPhiR=(*vars)[fTreeEntry*fNvars+1];
  Double_t mchelicity=(*vars)[fTreeEntry*fNvars+2];
   return 1.0;
}


